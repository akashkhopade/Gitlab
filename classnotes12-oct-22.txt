
Good Morning :))

		process, ISR , GPOS, Kernel mode, ready queue,
		After run state process may go to which state??
		
		printf enter num
		scanf num
		sqr = num * num
		printf sqr
		
		PC register 
		PCB
		process space / process address space
	___________________________________
	
	Process Scheduling --- 
		Many processes are waiting in the ready queue
		for the cpu
		
	Kernel  has a cpu schedular/ schedular / Low level schedular - it will decide which process should be selected from ready queue to use CPU next !!!
	
	Factors that are considered by cpu schedular while selecting the next process for CPU ---
	
	1. CPU burst time = total time needed for process to complete all CPU instructions
	
	2. IO burst time = 
	
	3. Wait time of a process = total time spent by the process in ready queue
	  average Wt  = sum of Wt of all processes/num of pr
	  This shoulbe as LOW as possible
	  
	4. TAT = Turnaround Time of a process = total time needed by the process to complete its life cycel
		TAT = Wt + Tcpu( cpu burst time)
		TAT = Completion time  - arrival time
		
		avg TAT = total of all processes/num of proces
	This should be as LOW as possible

	5. Througput of the system = number of processes completed in unit time.
		This should be as HIGH as possible
		
	6. Response time of a process = time taken by the process to respond to the user request
	  this should be as LOW as possible

    7. CPU utilization = for how long is the cpu being used from power on to power off
CPU utilization should be 100 percent - no IDLE time


CPU schedular works as per the scheduling algorithm that is implemented in the kernel.
Some basic CPU scheduling algorithms --
1. FIFO/FCFS = cpu schedular will select the process at the front of the ready queue for next execution.

	Ideally cpu is allocated as long as process completes
	In reality process may leave CPU if interrupt occurs or io instruction occur
	
Adv : Simple , all process get chance to run

Dis adv : if a small Tcpu process waits after long Tcpu process avg Wt increases,
        avg TAT increases
		Throughput decreases
		
	Process		Arrival time    Tcpu
	   P1         0               3ms
	   P2         2               5ms
	   P3         1               4ms
	   
	calculate the avg Wt and avg TAT using FIFO 
	Wt = start time - arrival time
	TAT = Wt + Tcpu
				Wt          TAT
	   P1     0-0=0         0+3=3
	   P2     7-2=5         5+5=10
	   P3     3-1=2         2+4=6
	  avg    0+5+2/3        3+10+6/3
	   
_________________________________________
2. SJF = Shortest Job First = cpu schedular will select the process having shortest cpu burst time from ready Q. 	      
	Ideally cpu is allocated as long as process completes
	In reality process may leave CPU if interrupt occurs or io instruction occur
	
Adv - avg Wt decreases, avg Tat decreases, throughput increase

dis adv - kernel cannot tell the Tcpu beforehand - its a theoretical algo , cannot be practically implemented

- STARVATION = of higher Tcpu process MAY occur !!!
________________________________________________
   
	calculate avg Wt and avg TAT using Non Preemptive SJF    
	 
	 process   arrival time      Tcpu
     P1			0               5
	 P2         2               4
	 P3         3               1
		
	process  Wt    TAT
     P1      0-0    0+5 = 5
     P2      6-2=4   4+4= 8
     P3      5-3=2    2+1=3
   avg      (0+4+2)/3   (5+8+3)/3
______________________________________
Preempt = Apply Force 
 process   arrival time      Tcpu
     P1			0               5
	 P2         2               4
	 P3         3               1
calculte avg Wt and avg TAT using Preemptive SJF

    process   Wt         TAT
	 P1      0-0=0             1 + 5 = 6
			 Resume-preempt
			 4-3= 1  
     P2      6-2= 4            4+4=8
	 P3      3-3=0              0+1 = 1
	 
average      (0+1+4+0)/3       (6+8+1)/3
_____________________________________________

Priority = cpu schedular will select a process having highest priority in the ready queue.

for ex - 1 to 10 priority . ( 1 is lowest , 10 is highest)

Usually kernel processes have higher priority than user processes.

For ex user process by default gets a priority of 5!!
programmatically we can change the priority of the process.

Preemptive Priority  = a new process having higher priority can preempt current process
	current process returns to ready Q
	new process uses CPU

Non Preemptive Priority = a new process having higher priority will wait in ready queue till current process terminates.

adv = priority is considered .
dis adv = STARVATION of low priority process MAY occur

Solution to Starvation = AGEING = process is promoted one level up as it waited for a long time

  process   arrival time   Tcpu     Priority
    P1           0          4          3
	P2           2           5         8
	P3           1           3         6
	 1 is lowest and 10 is highest
calculate the avg Wt and avg TAT using
2. preemptive priority
		process      Wt       TAT
		P1       (0-0)+(9-1)
					0+8=8      8+4=12
		P2       2-2=0         0+5=5
		P3      (1-1)+(7-2)
				  0+5= 5       5+3=8
		Avg =    (8+0+5)/3      (12+5+8)/3			

1. non preemptive priority

	process   Wt          TAT
	 P1      0-0=0        0+4=4
	 P2      4-2=2         2+5= 7
	 P3      9-1= 8        8+3= 11
Avg         (0+2+8)/3     (4+7+11)/3

_____________________________________

Context  =  snapshot of cpu registers at a given point of time [ it is holding the values of cpu registers just before process left CPU ]

CONTEXT SWITCHING -----------------
 context of out going process is saved 
 &
 context of incoming process is loaded in CPU

___________________________________________

4. Round Robin Scheduling = cpu schedular selects the process that is in the front of the ready Q!!
  ideally the process gets CPU only for a TIME QUANTUM
  
time quantum = time slice = small unit of time after which timer interrupt occurs

   Adv  = MULTITASKING  effect !!!
		 Response time is reduced !!!
		 
dis adv = avg Wt increases
          avg TAT increases
		  Throughput decreases
		  overhead of heavy context switching 

         process    arrival time     TCPU ms
		 P1           0               4
		 P2           1               3
		 P3           3               6
		 
		calculate avg Wt and avg TAT using RR
		Time slice = 2ms  
_________________

		Process    Wt         TAT 
		P1       (0-0)+(4-2)  2+4= 6
					0+2= 2
					
		P2      (2-1)+(8-4)    5+3=8
					1+4=5

        P3       (6-3)+(9-8)    4+6=10
				    3 + 1= 4

		avg     (2+5+4)/3       (6+8+10)/3

___________________________________________________

	Process    arrival time     Tcpu     Priority
	 P1           0              6          3
	 P2           3              2          6
	 P3           4              4          4
	 
	calculate avg Wt and avg TAT
	using
	 FIFO
	 Non preemptive SJF
	 Preemptive SJF
	 Non preemptive PRIORITY ( 1 lowest to 10 highest)
	 Preemptive PRIORITY
	 RR  ( Time slice = 2ms)
______________________________________________

relative paths --	
  mkdir ./cprog	= in the current folder create cprog
  mkdir cprog  = in the current folder create cprog
   mkdir  ../cprog = in the parent folder create cprog
   
 absolute path --it always starts with  / 
  mkdir /cprog = in the topmost folder create cprog
 ___________________
 gcc hello.c
 default output file is a.out  for gcc
 to give a different file use option -o after gcc
       gcc -o ./cprog/hello  ./cprog/hello.c
_________________________________
	 
	 
	 
	 





		
		
		
		
		
	


	
	  
	  
	  
	  
	  
	  
	  
	
	
	
	
	
	
	
		
		
		
		
		
		
		
		
		
		
		
		
		
		